// Copyright 2024 Ji Sungbin
// SPDX-License-Identifier: Apache-2.0
package land.sungbin.androidx.fetcher

import java.io.IOException
import okhttp3.internal.cache.DiskLruCache
import okhttp3.internal.concurrent.TaskRunner
import okhttp3.internal.concurrent.TaskRunner.RealBackend
import okio.Buffer
import okio.ByteString
import okio.FileSystem
import okio.Path
import okio.Source
import okio.buffer
import org.jetbrains.annotations.VisibleForTesting

// OkHttp's built-in cache works based on Cache-Control.
// But I want semi-persistent cache behaviour that is independent of Cache-Control.
@JvmInline public value class AndroidxRepositoryCache @VisibleForTesting internal constructor(
  @VisibleForTesting internal val cache: DiskLruCache,
) {
  public constructor(fileSystem: FileSystem, directory: Path, maxSize: Long) :
    this(
      DiskLruCache(
        fileSystem = fileSystem,
        directory = directory,
        appVersion = CACHE_VERSION,
        valueCount = ENTRY_SIZE,
        maxSize = maxSize,
        taskRunner = taskRunner(),
      ),
    )

  init {
    cache.initialize()
  }

  internal fun getCachedSource(ref: String): Source? {
    // Since the Source generated by DiskLruCache is close() sensitive,
    // we use a copy for ease of use.
    val candidateCache = cache[ref]?.getSource(ENTRY_BODY)?.use { source ->
      Buffer().apply { writeAll(source) }
    }

    return candidateCache
  }

  internal fun putSource(ref: String, source: ByteString): Boolean {
    var editor: DiskLruCache.Editor? = null
    return try {
      editor = cache.edit(ref) ?: return false
      editor.newSink(ENTRY_BODY).buffer().use { it.write(source) }
      editor.commit()
      true
    } catch (_: IOException) {
      try {
        editor?.abort()
      } catch (_: IOException) {
      }
      false
    }
  }

  public companion object {
    private const val ENTRY_BODY = 0
    @VisibleForTesting internal const val ENTRY_SIZE: Int = 1
    @VisibleForTesting internal const val CACHE_VERSION: Int = 1

    private fun taskRunner(): TaskRunner =
      TaskRunner(
        RealBackend { runnable ->
          Thread(runnable, AndroidxRepositoryCache::class.simpleName!!).apply { isDaemon = true }
        },
      )
  }
}
